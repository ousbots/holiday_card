use bevy::prelude::*;

use crate::interaction::{Highlight, Interactable, aabb_overlap};

// Click component for click feedback sprite.
#[derive(Component)]
struct Click;

// Timer to track click indicator fade.
#[derive(Component)]
struct ClickFade(Timer);

// Cursor world position to cache the calculation.
#[derive(Resource, Default)]
struct CursorWorldPosition {
    position: Option<Vec2>,
}

// Input directions.
#[derive(Component, Clone, Copy, Debug, Eq, PartialEq)]
pub enum Direction {
    Left,
    Right,
    Up,
}

// Input events generated by the user.
#[derive(Debug, Default, Message)]
pub struct InputEvent {
    pub direction: Option<Direction>,
    pub target: Option<InputTarget>,
}

#[derive(Clone, Copy, Debug)]
pub struct InputTarget {
    pub x: f32,
    pub action: bool,
}

// Cursor size for aabb detection.
const CURSOR_SIZE: f32 = 0.1;

// Initialize input systems.
pub fn add_systems(app: &mut App) {
    app.init_resource::<CursorWorldPosition>().add_systems(
        Update,
        (
            handle_fade,
            handle_keys,
            handle_mouse_input,
            update_cursor_position.before(detect_mouse_hover),
            detect_mouse_hover,
        ),
    );
}

// Fade marker alpha over time
fn handle_fade(
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<(Entity, &mut Sprite, &mut ClickFade), With<Click>>,
) {
    for (entity, mut sprite, mut fade) in &mut query {
        fade.0.tick(time.delta());

        // Calculate fade progress (0.0 to 1.0)
        let progress = fade.0.elapsed_secs() / fade.0.duration().as_secs_f32();

        // Fade from 0.8 to 0.0 alpha
        let alpha = 0.8 * (1.0 - progress);
        sprite.color.set_alpha(alpha);

        if fade.0.just_finished() {
            commands.entity(entity).despawn();
        }
    }
}

// Handle key input and send events.
fn handle_keys(keyboard: Res<ButtonInput<KeyCode>>, mut input_events: MessageWriter<InputEvent>) {
    // Check for key presses.
    if keyboard.just_pressed(KeyCode::ArrowLeft) {
        input_events.write(InputEvent {
            direction: Some(Direction::Left),
            ..default()
        });
    } else if keyboard.just_pressed(KeyCode::ArrowRight) {
        input_events.write(InputEvent {
            direction: Some(Direction::Right),
            ..default()
        });
    } else if keyboard.just_pressed(KeyCode::ArrowUp) {
        input_events.write(InputEvent {
            direction: Some(Direction::Up),
            ..default()
        });
    }

    // Check for final key releases.
    if keyboard.just_released(KeyCode::ArrowLeft) && !keyboard.any_pressed(vec![KeyCode::ArrowLeft, KeyCode::ArrowUp]) {
        input_events.write(InputEvent::default());
    }
    if keyboard.just_released(KeyCode::ArrowRight) && !keyboard.any_pressed(vec![KeyCode::ArrowLeft, KeyCode::ArrowUp])
    {
        input_events.write(InputEvent::default());
    }
    if keyboard.just_released(KeyCode::ArrowUp) && !keyboard.any_pressed(vec![KeyCode::ArrowLeft, KeyCode::ArrowRight])
    {
        input_events.write(InputEvent::default());
    }
}

// Handle mouse input and send events.
fn handle_mouse_input(
    mut commands: Commands,
    mouse_input: Res<ButtonInput<MouseButton>>,
    windows: Query<&Window>,
    camera_query: Query<(&Camera, &GlobalTransform), With<Camera2d>>,
    interactables: Query<(&GlobalTransform, &Interactable)>,
    mut input_events: MessageWriter<InputEvent>,
) {
    if mouse_input.just_pressed(MouseButton::Left) {
        // Convert cursor position to world coordinates.
        let Ok(window) = windows.single() else {
            return;
        };
        let Some(cursor_pos): Option<Vec2> = window.cursor_position() else {
            return;
        };
        let Ok((camera, camera_transform)) = camera_query.single() else {
            return;
        };
        let Ok(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) else {
            return;
        };

        let action: bool = interactables.iter().any(|(transform, interactable)| {
            aabb_overlap(
                world_pos,
                CURSOR_SIZE,
                CURSOR_SIZE,
                transform.translation().truncate(),
                interactable.width,
                interactable.height,
            )
        });

        input_events.write(InputEvent {
            target: Some(InputTarget {
                x: world_pos.x,
                action: action,
            }),
            ..default()
        });

        commands.spawn((
            Sprite {
                color: Color::srgba(1.0, 1.0, 0.0, 0.8),
                custom_size: Some(Vec2::splat(3.0)),
                ..default()
            },
            Transform::from_translation(Vec3::new(world_pos.x, world_pos.y, 10.0)),
            Click,
            ClickFade(Timer::from_seconds(1.0, TimerMode::Once)),
        ));
    }
}

// Update the cursor world position.
fn update_cursor_position(
    mut cursor_res: ResMut<CursorWorldPosition>,
    windows: Query<&Window>,
    camera_query: Query<(&Camera, &GlobalTransform), With<Camera2d>>,
) {
    let Ok(window) = windows.single() else {
        cursor_res.position = None;
        return;
    };
    let Some(cursor_pos) = window.cursor_position() else {
        cursor_res.position = None;
        return;
    };
    let Ok((camera, camera_transform)) = camera_query.single() else {
        cursor_res.position = None;
        return;
    };
    let Ok(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) else {
        cursor_res.position = None;
        return;
    };

    cursor_res.position = Some(world_pos);
}

// Detect mouse hover over interactable entities and add/remove Highlight component.
fn detect_mouse_hover(
    time: Res<Time>,
    mut commands: Commands,
    cursor_res: Res<CursorWorldPosition>,
    interactables: Query<(Entity, &GlobalTransform, &Interactable)>,
    highlighted: Query<&Highlight>,
) {
    // Use cached cursor world position.
    let Some(world_pos) = cursor_res.position else {
        return;
    };

    // Check each interactable for overlap with cursor.
    for (entity, transform, interactable) in &interactables {
        let overlapping = aabb_overlap(
            world_pos,
            CURSOR_SIZE,
            CURSOR_SIZE,
            transform.translation().truncate(),
            interactable.width,
            interactable.height,
        );

        let currently_highlighted = highlighted.contains(entity);

        match (currently_highlighted, overlapping) {
            // New hover - add highlight if conditions met.
            (false, true) => {
                commands.entity(entity).insert(Highlight {
                    elapsed_offset: time.elapsed_secs(),
                });
            }
            // Hover ended - remove highlight.
            (true, false) => {
                commands.entity(entity).remove::<Highlight>();
            }
            _ => {}
        }
    }
}
