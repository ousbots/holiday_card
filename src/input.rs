use bevy::prelude::*;

// Click component for click feedback sprite.
#[derive(Component)]
struct Click;

// Timer to track click indicator fade.
#[derive(Component)]
struct ClickFade(Timer);

// Input directions.
#[derive(Component, Clone, Copy, Debug, PartialEq)]
pub enum Direction {
    Left,
    Right,
    Up,
}

// Input events generated by the user.
#[derive(Debug, Default, Message)]
pub struct InputEvent {
    pub direction: Option<Direction>,
    pub target: Option<InputTarget>,
}

#[derive(Clone, Copy, Debug)]
pub struct InputTarget {
    pub x: f32,
    pub y: f32,
}

pub fn add_systems(app: &mut App) {
    app.add_systems(Update, (handle_fade, handle_keys, handle_mouse_input));
}

// Fade marker alpha over time
fn handle_fade(
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<(Entity, &mut Sprite, &mut ClickFade), With<Click>>,
) {
    for (entity, mut sprite, mut fade) in &mut query {
        fade.0.tick(time.delta());

        // Calculate fade progress (0.0 to 1.0)
        let progress = fade.0.elapsed_secs() / fade.0.duration().as_secs_f32();

        // Fade from 0.8 to 0.0 alpha
        let alpha = 0.8 * (1.0 - progress);
        sprite.color.set_alpha(alpha);

        if fade.0.just_finished() {
            commands.entity(entity).despawn();
        }
    }
}

// Handle key input and send input events.
fn handle_keys(keyboard: Res<ButtonInput<KeyCode>>, mut input_events: MessageWriter<InputEvent>) {
    // Check for key presses.
    if keyboard.just_pressed(KeyCode::ArrowLeft) {
        input_events.write(InputEvent {
            direction: Some(Direction::Left),
            ..default()
        });
    } else if keyboard.just_pressed(KeyCode::ArrowRight) {
        input_events.write(InputEvent {
            direction: Some(Direction::Right),
            ..default()
        });
    } else if keyboard.just_pressed(KeyCode::ArrowUp) {
        input_events.write(InputEvent {
            direction: Some(Direction::Up),
            ..default()
        });
    }

    // Check for final key releases.
    if keyboard.just_released(KeyCode::ArrowLeft) && !keyboard.any_pressed(vec![KeyCode::ArrowLeft, KeyCode::ArrowUp]) {
        input_events.write(InputEvent::default());
    }
    if keyboard.just_released(KeyCode::ArrowRight) && !keyboard.any_pressed(vec![KeyCode::ArrowLeft, KeyCode::ArrowUp])
    {
        input_events.write(InputEvent::default());
    }
    if keyboard.just_released(KeyCode::ArrowUp) && !keyboard.any_pressed(vec![KeyCode::ArrowLeft, KeyCode::ArrowRight])
    {
        input_events.write(InputEvent::default());
    }
}

// Handle mouse input and send input events.
fn handle_mouse_input(
    mut commands: Commands,
    mouse_input: Res<ButtonInput<MouseButton>>,
    windows: Query<&Window>,
    camera_query: Query<(&Camera, &GlobalTransform), With<Camera2d>>,
    mut input_events: MessageWriter<InputEvent>,
) {
    if mouse_input.just_pressed(MouseButton::Left) {
        // Convert cursor position to world coordinates.
        let Ok(window) = windows.single() else {
            return;
        };
        let Some(cursor_pos): Option<Vec2> = window.cursor_position() else {
            return;
        };
        let Ok((camera, camera_transform)) = camera_query.single() else {
            return;
        };
        let Ok(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) else {
            return;
        };

        input_events.write(InputEvent {
            target: Some(InputTarget {
                x: world_pos.x,
                y: world_pos.y,
            }),
            ..default()
        });

        commands.spawn((
            Sprite {
                color: Color::srgba(1.0, 1.0, 0.0, 0.8),
                custom_size: Some(Vec2::splat(3.0)),
                ..default()
            },
            Transform::from_translation(Vec3::new(world_pos.x, world_pos.y, 10.0)),
            Click,
            ClickFade(Timer::from_seconds(1.0, TimerMode::Once)),
        ));
    }
}
